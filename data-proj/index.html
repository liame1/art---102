<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Playtime Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace, Geneva, Verdana, sans-serif;
            background-image: url("nebula.gif");
            background-size: cover;
            min-height: 100vh;
            overflow: hidden;
        }

        .header {
            position: absolute;
            top: 1%;
            left: 1%;
            padding: 1px;
            z-index: 100;
            text-align: center;
        }

        h1 {
            color: white;
            font-size: 1.2em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .stats {
            color: rgba(238, 238, 238, 0.9);
            font-size: 1em;
        }

        .controls {
            position: absolute;
            top: 3%;
            right: 2%;
            background: rgba(255, 255, 255, 0.5);
            padding: 2px 5px;
            z-index: 100;
            color: rgb(63, 59, 59);
            text-align: center;
        }

        .control-item {
            font-size: 0.95em;
            margin: 5px 0;
            opacity: 0.9;
        }

        #canvas {
            width: 100%;
            height: 100vh;
            display: block;
        }

        .tooltip {
            position: absolute;
            background: rgba(32, 32, 32, 0.9);
            color: white;
            padding: 5px 8px;
            border-radius: 2px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 1000;
            font-size: 14px;
            white-space: nowrap;
        }

        #img-1 {
            position: absolute;
            transform: translate(400%, 230%);
            width: 15em;
            pointer-events: none;
        }

        #img-2 {
            position: absolute;
            transform: translate(120%, -80%);
            pointer-events: none;
            width: 8em;
        }

        #img-3 {
            position: absolute;
            transform: translate(660%, 40%);
            width: 10em;
            pointer-events: none;
        }
        #img-4 {
            position: absolute;
            transform: translate(-65%, 170%);
            width: 15em;
            pointer-events: none;
        }

        p {
            font-size: 0.8em;
            color: white;
            position: absolute;
            margin-top: 8%;
            pointer-events: none;
        }

    </style>
</head>

<body>
    <div class="header">
        <h1> This is how many hours <br>I've clocked on my steam account</h1>
        <div class="stats">
            Total: <span id="totalGames"></span> games | <span id="totalHours"></span> hours played
        </div>
        <p>
            Its weird seeing all of this time visualized and sitting here like this. I dont think I'm necessarly addicted to video games, but
            its a large part of my life. I wonder what I could have done with all this time instead. Would it have been
            better spent on other things? I mean in the grand scheme of things it doesn't really matter, all of these
            hours were spend on a leisureful activity, and it's an activity that I enjoy. I mean ultamitley, if the best parts of life are finding
            momentary distractions to keep yourself busy, than I have been living it up by playing video games. My parents said that I would
            eventually be done with video games when I grow older, but video games have been one of the only true consistancies throughout my
            life. I wonder if reflecting apon this is a good thing or not.
        </p>
        <div>
            <img id="img-1" src="backofbricks.gif">
            <img id="img-2" src="faceoffman.gif">
            <img id="img-3" src="steam-brain.png">
            <img id="img-4" src="videogamegeeks.JPG">
        </div>
    </div>

    <canvas id="canvas"></canvas>
    <div class="tooltip" id="tooltip"></div>

    <div class="controls">
        <div class="control-item"><b>Left click</b> to interact <br> <b>Right click</b> to pan view <br> <b>Scroll</b>
            to zoom</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script>
        const gameData = [
            { name: "Among Us", hours: 50 },
            { name: "Animal Well", hours: 17 },
            { name: "ANNO Mutationem", hours: 15 },
            { name: "Astroneer", hours: 60 },
            { name: "The Beginners Guide", hours: 14 },
            { name: "Counter Strike", hours: 213 },
            { name: "Crab Game", hours: 33 },
            { name: "Cyberpunk 2077", hours: 95 },
            { name: "Deceit", hours: 14 },
            { name: "Deducto", hours: 7 },
            { name: "A Difficult Game About Climbing", hours: 22 },
            { name: "The Escapists", hours: 8 },
            { name: "Fall Guys", hours: 41 },
            { name: "The Finals", hours: 101 },
            { name: "Foundation", hours: 11 },
            { name: "Friends vs. Friends", hours: 6 },
            { name: "Garry's Mod", hours: 9 },
            { name: "Getting Over It", hours: 20 },
            { name: "Lethal Company", hours: 19 },
            { name: "Mage Arena", hours: 6 },
            { name: "Night at the Gates of Hell", hours: 10 },
            { name: "Omori", hours: 8 },
            { name: "Only Up", hours: 5 },
            { name: "Phasmophobia", hours: 34 },
            { name: "Raft", hours: 18 },
            { name: "Rust", hours: 1472 },
            { name: "Civilization V", hours: 386 },
            { name: "Splitgate", hours: 7 },
            { name: "The Stanley Parable", hours: 7 },
            { name: "Team Fortress 2", hours: 6 },
            { name: "Tiny Terraces", hours: 13 },
            { name: "Vampire Blood Hunt", hours: 24 },
            { name: "VR Chat", hours: 6 }
        ];

        const totalHours = gameData.reduce((sum, game) => sum + game.hours, 0);
        document.getElementById('totalGames').textContent = gameData.length;
        document.getElementById('totalHours').textContent = totalHours.toLocaleString();

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const tooltip = document.getElementById('tooltip');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        const maxHours = Math.max(...gameData.map(g => g.hours));
        const minRadius = 20;
        const maxRadius = 250;

        function calculateRadius(hours) {
            const sqrtHours = Math.sqrt(hours);
            const sqrtMax = Math.sqrt(maxHours);
            return minRadius + (sqrtMax > 0 ? (sqrtHours / sqrtMax) * (maxRadius - minRadius) : 0);
        }

        const gameColors = {
            "Rust": "#aa2704",
            "Counter Strike": "#ff6b35",
            "Civilization V": "#4a90e2",
            "Cyberpunk 2077": "#00ffff",
            "The Finals": "#ffd700",
            "Astroneer": "#9b59b6",
            "Among Us": "#ff4757",
            "Fall Guys": "#ff6348",
            "Phasmophobia": "#2ecc71",
            "Crab Game": "#e74c3c",
            "Lethal Company": "#34495e",
            "Vampire Blood Hunt": "#8b0000",
            "A Difficult Game About Climbing": "#95a5a6",
            "Getting Over It": "#7f8c8d",
            "Raft": "#3498db",
            "Animal Well": "#27ae60",
            "ANNO Mutationem": "#e056fd",
            "The Beginners Guide": "#bdc3c7",
            "Deceit": "#c0392b",
            "Deducto": "#f39c12",
            "The Escapists": "#d35400",
            "Foundation": "#16a085",
            "Friends vs. Friends": "#ff9ff3",
            "Garry's Mod": "#f368e0",
            "Mage Arena": "#8e44ad",
            "Night at the Gates of Hell": "#2c3e50",
            "Omori": "#ee5a6f",
            "Only Up": "#1abc9c",
            "Splitgate": "#5f27cd",
            "The Stanley Parable": "#f8b739",
            "Team Fortress 2": "#ff7979",
            "Tiny Terraces": "#78e08f",
            "VR Chat": "#4bcffa"
        };

        const nodes = gameData.map(game => {
            const radius = calculateRadius(game.hours);
            const angle = Math.random() * Math.PI * 2;
            const distance = 100 + Math.random() * 300;
            const isRust = game.name === "Rust";

            return {
                ...game,
                radius: radius,
                x: isRust ? canvas.width / 2 : canvas.width / 2 + Math.cos(angle) * distance,
                y: isRust ? canvas.height / 2 : canvas.height / 2 + Math.sin(angle) * distance,
                vx: isRust ? 0 : -Math.sin(angle) * 0.5,
                vy: isRust ? 0 : Math.cos(angle) * 0.5,
                color: gameColors[game.name] || `hsl(${Math.random() * 360}, 70%, 65%)`,
                static: isRust,
                pulseOffset: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.02,
                rotation: 0,
                glowIntensity: 0
            };
        });

        let camera = { x: 0, y: 0, scale: 1 };
        let draggedNode = null;
        let isDragging = false;
        let isPanning = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let mouseX = 0;
        let mouseY = 0;
        let time = 0;

        function applyForces() {
            const G = 0.05;

            for (let i = 0; i < nodes.length; i++) {
                if (nodes[i] === draggedNode || nodes[i].static) continue;

                for (let j = 0; j < nodes.length; j++) {
                    if (i === j) continue;

                    const dx = nodes[j].x - nodes[i].x;
                    const dy = nodes[j].y - nodes[i].y;
                    const distSq = dx * dx + dy * dy;
                    const distance = Math.sqrt(distSq);

                    if (distance > 1) {
                        const force = (G * nodes[j].radius * nodes[j].radius) / distSq;
                        const forceX = (dx / distance) * force;
                        const forceY = (dy / distance) * force;

                        nodes[i].vx += forceX;
                        nodes[i].vy += forceY;
                    }
                }
            }

            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const dx = nodes[j].x - nodes[i].x;
                    const dy = nodes[j].y - nodes[i].y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const minDist = nodes[i].radius + nodes[j].radius;

                    if (distance < minDist && distance > 0) {
                        const angle = Math.atan2(dy, dx);
                        const overlap = minDist - distance;

                        if (nodes[i].static && !nodes[j].static) {
                            nodes[j].x += Math.cos(angle) * overlap;
                            nodes[j].y += Math.sin(angle) * overlap;
                            nodes[j].vx += (dx / distance) * 0.1;
                            nodes[j].vy += (dy / distance) * 0.1;
                        } else if (nodes[j].static && !nodes[i].static) {
                            nodes[i].x -= Math.cos(angle) * overlap;
                            nodes[i].y -= Math.sin(angle) * overlap;
                            nodes[i].vx -= (dx / distance) * 0.1;
                            nodes[i].vy -= (dy / distance) * 0.1;
                        } else if (!nodes[i].static && !nodes[j].static) {
                            const pushX = Math.cos(angle) * overlap * 0.5;
                            const pushY = Math.sin(angle) * overlap * 0.5;

                            nodes[i].x -= pushX;
                            nodes[i].y -= pushY;
                            nodes[j].x += pushX;
                            nodes[j].y += pushY;

                            const mass1 = nodes[i].radius * nodes[i].radius;
                            const mass2 = nodes[j].radius * nodes[j].radius;
                            const totalMass = mass1 + mass2;

                            nodes[i].vx -= (dx / distance) * 0.1 * (mass2 / totalMass);
                            nodes[i].vy -= (dy / distance) * 0.1 * (mass2 / totalMass);
                            nodes[j].vx += (dx / distance) * 0.1 * (mass1 / totalMass);
                            nodes[j].vy += (dy / distance) * 0.1 * (mass1 / totalMass);
                        }
                    }
                }
            }

            nodes.forEach(node => {
                if (node !== draggedNode && !node.static) {
                    node.x += node.vx;
                    node.y += node.vy;
                    node.vx *= 0.98;
                    node.vy *= 0.98;
                }
            });
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();

            ctx.translate(camera.x, camera.y);
            ctx.scale(camera.scale, camera.scale);

            nodes.forEach(node => {
                node.rotation += node.rotationSpeed;
                const pulse = Math.sin(time * 0.05 + node.pulseOffset) * 0.05 + 1;
                const currentRadius = node.radius * pulse;

                // Outer glow
                const gradient = ctx.createRadialGradient(node.x, node.y, 0, node.x, node.y, currentRadius * 1.3);
                gradient.addColorStop(0, node.color);
                gradient.addColorStop(0.7, node.color);
                gradient.addColorStop(1, node.color + '00');

                ctx.beginPath();
                ctx.arc(node.x, node.y, currentRadius * 1.3, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();

                // Main circle with shimmer effect
                ctx.save();
                ctx.translate(node.x, node.y);
                ctx.rotate(node.rotation);

                const mainGradient = ctx.createRadialGradient(-currentRadius * 0.3, -currentRadius * 0.3, 0, 0, 0, currentRadius);
                mainGradient.addColorStop(0, addAlpha(lightenColor(node.color, 40), 1));
                mainGradient.addColorStop(0.5, node.color);
                mainGradient.addColorStop(1, addAlpha(darkenColor(node.color, 30), 1));

                ctx.beginPath();
                ctx.arc(0, 0, currentRadius, 0, Math.PI * 2);
                ctx.fillStyle = mainGradient;
                ctx.fill();

                // Animated ring pattern
                ctx.strokeStyle = 'rgba(255,255,255,0.2)';
                ctx.lineWidth = 2;
                for (let i = 0; i < 3; i++) {
                    const ringRadius = currentRadius * (0.3 + i * 0.25);
                    const ringAlpha = (Math.sin(time * 0.08 + i) + 1) * 0.15;
                    ctx.strokeStyle = `rgba(255,255,255,${ringAlpha})`;
                    ctx.beginPath();
                    ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                    ctx.stroke();
                }

                ctx.restore();

                // Border with shimmer
                ctx.beginPath();
                ctx.arc(node.x, node.y, currentRadius, 0, Math.PI * 2);
                const shimmer = (Math.sin(time * 0.1 + node.pulseOffset) + 1) * 0.25 + 0.3;
                ctx.strokeStyle = `rgba(255,255,255,${shimmer})`;
                ctx.lineWidth = 3;
                ctx.stroke();

                // Sparkles
                if (Math.random() > 0.97) {
                    const sparkleAngle = Math.random() * Math.PI * 2;
                    const sparkleDistance = Math.random() * currentRadius * 0.8;
                    const sparkleX = node.x + Math.cos(sparkleAngle) * sparkleDistance;
                    const sparkleY = node.y + Math.sin(sparkleAngle) * sparkleDistance;

                    ctx.fillStyle = 'rgba(255,255,255,0.8)';
                    ctx.beginPath();
                    ctx.arc(sparkleX, sparkleY, 2, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Text with shadow
                ctx.fillStyle = '#fff';
                ctx.shadowColor = 'rgba(0,0,0,0.8)';
                ctx.shadowBlur = 8;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                const fontSize = Math.max(12, node.radius / 3);
                ctx.font = `bold ${fontSize}px 'Segoe UI', sans-serif`;
                ctx.fillText(`${node.hours}h`, node.x, node.y);

                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
            });

            ctx.restore();
        }

        function lightenColor(color, percent) {
            const num = parseInt(color.replace("#", ""), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.min(255, (num >> 16) + amt);
            const G = Math.min(255, (num >> 8 & 0x00FF) + amt);
            const B = Math.min(255, (num & 0x0000FF) + amt);
            return "#" + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }

        function darkenColor(color, percent) {
            const num = parseInt(color.replace("#", ""), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.max(0, (num >> 16) - amt);
            const G = Math.max(0, (num >> 8 & 0x00FF) - amt);
            const B = Math.max(0, (num & 0x0000FF) - amt);
            return "#" + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }

        function addAlpha(color, alpha) {
            return color + Math.round(alpha * 255).toString(16).padStart(2, '0');
        }

        function animate() {
            time++;
            applyForces();
            draw();
            requestAnimationFrame(animate);
        }
        animate();

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            return {
                x: (clientX - rect.left - camera.x) / camera.scale,
                y: (clientY - rect.top - camera.y) / camera.scale
            };
        }

        function getNodeAtPosition(x, y) {
            for (let i = nodes.length - 1; i >= 0; i--) {
                const node = nodes[i];
                const dx = x - node.x;
                const dy = y - node.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < node.radius) {
                    return node;
                }
            }
            return null;
        }

        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 2) {
                e.preventDefault();
                isPanning = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                canvas.style.cursor = 'move';
                return;
            }

            if (e.button === 0) {
                const pos = getMousePos(e);
                draggedNode = getNodeAtPosition(pos.x, pos.y);

                if (draggedNode) {
                    isDragging = true;
                    canvas.style.cursor = 'grabbing';
                } else {
                    isPanning = true;
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                    canvas.style.cursor = 'move';
                }
            }
        });

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        canvas.addEventListener('mousemove', (e) => {
            const pos = getMousePos(e);
            mouseX = pos.x;
            mouseY = pos.y;

            if (isDragging && draggedNode) {
                draggedNode.x = pos.x;
                draggedNode.y = pos.y;
                draggedNode.vx = 0;
                draggedNode.vy = 0;
                tooltip.style.opacity = '0';
            } else if (isPanning) {
                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;
                camera.x += dx;
                camera.y += dy;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                tooltip.style.opacity = '0';
            } else {
                const hoveredNode = getNodeAtPosition(pos.x, pos.y);
                if (hoveredNode) {
                    canvas.style.cursor = 'grab';
                    tooltip.textContent = `${hoveredNode.name} - ${hoveredNode.hours} hours`;
                    tooltip.style.left = e.clientX + 15 + 'px';
                    tooltip.style.top = e.clientY + 15 + 'px';
                    tooltip.style.opacity = '1';
                } else {
                    canvas.style.cursor = 'default';
                    tooltip.style.opacity = '0';
                }
            }
        });

        canvas.addEventListener('mouseup', () => {
            draggedNode = null;
            isDragging = false;
            isPanning = false;
            canvas.style.cursor = 'default';
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = camera.scale * delta;

            if (newScale >= 0.3 && newScale <= 3) {
                const mouseX = e.clientX - canvas.width / 2;
                const mouseY = e.clientY - canvas.height / 2;

                camera.x -= mouseX * (delta - 1);
                camera.y -= mouseY * (delta - 1);
                camera.scale = newScale;
            }
        });
    </script>
</body>

</html>