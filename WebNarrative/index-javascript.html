<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive JavaScript Experience - Multi-Zone Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow-x: hidden;
            scroll-behavior: smooth;
        }
        
        .zone {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }
        
        /* Zone 1: Title Page */
        .zone-1 {
            background: linear-gradient(45deg, #667eea, #764ba2, #f093fb, #f5576c);
            background-size: 400% 400%;
            animation: gradientShift 8s ease infinite;
        }
        
        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        .title-content {
            text-align: center;
            color: white;
            z-index: 10;
            position: relative;
        }
        
        .main-title {
            font-size: 4em;
            font-weight: bold;
            margin-bottom: 20px;
            text-shadow: 0 0 30px rgba(255,255,255,0.5);
            animation: titleGlow 2s ease-in-out infinite alternate;
        }
        
        @keyframes titleGlow {
            from { text-shadow: 0 0 30px rgba(255,255,255,0.5); }
            to { text-shadow: 0 0 50px rgba(255,255,255,0.8), 0 0 80px rgba(255,255,255,0.3); }
        }
        
        .subtitle {
            font-size: 1.5em;
            margin-bottom: 40px;
            opacity: 0.9;
        }
        
        .scroll-indicator {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 1.2em;
            animation: bounce 2s infinite;
        }
        
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateX(-50%) translateY(0); }
            40% { transform: translateX(-50%) translateY(-10px); }
            60% { transform: translateX(-50%) translateY(-5px); }
        }
        
        /* Zone 2: Fireworks Demo */
        .zone-2 {
            background: linear-gradient(135deg, #2c3e50, #34495e, #3498db);
            color: white;
        }
        
        .demo-container {
            max-width: 800px;
            text-align: center;
            padding: 40px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .zone-title {
            font-size: 2.5em;
            margin-bottom: 20px;
            color: #feca57;
        }
        
        .zone-description {
            font-size: 1.2em;
            margin-bottom: 30px;
            opacity: 0.9;
        }
        
        .fireworks-button {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #feca57);
            background-size: 300% 300%;
            animation: gradientShift 3s ease infinite;
            color: white;
            padding: 20px 40px;
            border-radius: 50px;
            border: none;
            font-size: 1.3em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 3px solid #fff;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            position: relative;
            overflow: hidden;
        }
        
        .fireworks-button:hover {
            transform: scale(1.05) rotate(2deg);
            box-shadow: 0 20px 40px rgba(0,0,0,0.4);
        }
        
        .fireworks-button:active {
            transform: scale(0.95);
        }
        
        .mouse-tracker {
            position: fixed;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, rgba(255,255,255,0.8), rgba(255,255,255,0.2));
            border-radius: 50%;
            pointer-events: none;
            z-index: 2000;
            transition: none;
            box-shadow: 0 0 20px rgba(255,255,255,0.5);
        }
        
        .dynamic-element {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #ff6b6b;
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
            transition: none;
        }
        
        .gravity-well {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            opacity: 0.3;
            animation: pulse 2s infinite;
        }
        
        .data-visualization {
            position: absolute;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            pointer-events: none;
            z-index: 1500;
        }
        
        /* Zone 3: Interactive Particles */
        .zone-3 {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }
        
        .particle-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .interactive-area {
            width: 100%;
            height: 400px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: crosshair;
            position: relative;
            overflow: hidden;
        }
        
        .interactive-text {
            font-size: 1.5em;
            text-align: center;
            opacity: 0.7;
        }
        
        /* Zone 4: Color Changing Demo */
        .zone-4 {
            background: linear-gradient(135deg, #f093fb, #f5576c);
            color: white;
        }
        
        .color-demo {
            width: 300px;
            height: 300px;
            border-radius: 50%;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            margin: 20px auto;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            position: relative;
            overflow: hidden;
        }
        
        .color-demo:hover {
            transform: scale(1.1);
        }
        
        .color-demo::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: conic-gradient(transparent, rgba(255,255,255,0.3), transparent);
            animation: rotate 3s linear infinite;
        }
        
        @keyframes rotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Zone 5: Text Animation */
        .zone-5 {
            background: linear-gradient(135deg, #96ceb4, #feca57);
            color: #2c3e50;
        }
        
        /* Zone 6: Animated Fractal Demo */
        .zone-6 {
            background: linear-gradient(135deg, #2c3e50, #34495e, #8e44ad);
            color: white;
        }
        
        .fractal-canvas {
            width: 100%;
            height: 500px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
        }
        
        .fractal-controls {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .fractal-btn {
            padding: 12px 24px;
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            border: none;
            border-radius: 25px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .fractal-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.3);
        }
        
        .fractal-btn:active {
            transform: translateY(0);
        }
        
        .fractal-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .stat-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            backdrop-filter: blur(10px);
        }
        
        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #feca57;
        }
        
        .stat-label {
            font-size: 0.9em;
            opacity: 0.8;
        }
        
        .fractal-element {
            position: absolute;
            pointer-events: none;
        }
        
        .fractal-tree-branch {
            position: absolute;
            background: linear-gradient(to bottom, #8B4513, #654321);
            transform-origin: bottom center;
        }
        
        .fractal-triangle {
            position: absolute;
            width: 0;
            height: 0;
            border-style: solid;
        }
        
        .fractal-point {
            position: absolute;
            width: 2px;
            height: 2px;
            background: #feca57;
            border-radius: 50%;
            box-shadow: 0 0 5px #feca57;
        }
        
        .animated-text {
            font-size: 3em;
            font-weight: bold;
            text-align: center;
            margin: 20px 0;
        }
        
        .typing-text {
            border-right: 3px solid #2c3e50;
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 50% { border-color: transparent; }
            51%, 100% { border-color: #2c3e50; }
        }
        
        /* Floating elements for all zones */
        .floating-elements {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
        
        .floating-element {
            position: absolute;
            width: 20px;
            height: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 50%;
            animation: float 6s ease-in-out infinite;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(180deg); }
        }
        
        /* Firework styles */
        .firework {
            position: fixed;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
        }
        
        .firework-trail {
            position: fixed;
            width: 2px;
            height: 2px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 999;
        }
        
        /* Navigation dots */
        .nav-dots {
            position: fixed;
            right: 30px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 100;
        }
        
        .nav-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            margin: 10px 0;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .nav-dot.active {
            background: white;
            transform: scale(1.5);
        }
        
        .nav-dot:hover {
            background: rgba(255, 255, 255, 0.8);
            transform: scale(1.2);
        }
    </style>
</head>
<body>
    <div class="floating-elements" id="floatingElements"></div>
    <canvas class="particle-canvas" id="particleCanvas"></canvas>
    
    <!-- Navigation Dots -->
    <div class="nav-dots">
        <div class="nav-dot active" data-zone="1"></div>
        <div class="nav-dot" data-zone="2"></div>
        <div class="nav-dot" data-zone="3"></div>
        <div class="nav-dot" data-zone="4"></div>
        <div class="nav-dot" data-zone="5"></div>
        <div class="nav-dot" data-zone="6"></div>
    </div>
    
    <!-- Zone 1: Title Page -->
    <div class="zone zone-1" id="zone1">
        <div class="title-content">
            <h1 class="main-title">JavaScript Magic</h1>
            <p class="subtitle">Interactive Web Experiences</p>
            <p>Scroll down to explore amazing JavaScript demos!</p>
        </div>
        <div class="scroll-indicator">↓ Scroll Down ↓</div>
    </div>
    
    <!-- Zone 2: Fireworks Demo -->
    <div class="zone zone-2" id="zone2">
        <div class="demo-container">
            <h2 class="zone-title">🎆 Fireworks Show</h2>
            <p class="zone-description">Click the button to launch spectacular fireworks that fly from the bottom and explode in the sky!</p>
            <button class="fireworks-button" onclick="launchFireworks()">
                🚀 LAUNCH FIREWORKS! 🎆
            </button>
        </div>
    </div>
    
    <!-- Zone 3: Interactive Particles -->
    <div class="zone zone-3" id="zone3">
        <div class="demo-container">
            <h2 class="zone-title">✨ Interactive Particles</h2>
            <p class="zone-description">Move your mouse around the area below to create beautiful particle effects!</p>
            <div class="interactive-area" id="interactiveArea">
                <p class="interactive-text">Move your mouse here to create particles!</p>
            </div>
        </div>
    </div>
    
    <!-- Zone 4: Color Changing Demo -->
    <div class="zone zone-4" id="zone4">
        <div class="demo-container">
            <h2 class="zone-title">🎨 Color Magic</h2>
            <p class="zone-description">Click the circle to see it change colors and create beautiful patterns!</p>
            <div class="color-demo" id="colorDemo"></div>
        </div>
    </div>
    
    <!-- Zone 5: Text Animation -->
    <div class="zone zone-5" id="zone5">
        <div class="demo-container">
            <h2 class="zone-title">📝 Text Animation</h2>
            <p class="zone-description">Watch the text animate with typing effects and dynamic transformations!</p>
            <div class="animated-text" id="animatedText">Welcome to JavaScript!</div>
        </div>
    </div>
    
    <!-- Zone 6: Animated Fractal Demo -->
    <div class="zone zone-6" id="zone6">
        <div class="demo-container">
            <h2 class="zone-title">🌀 Animated Fractals</h2>
            <p class="zone-description">Explore the infinite beauty of mathematical fractals with JavaScript-powered recursive algorithms and complex number calculations!</p>
            
            <div class="fractal-controls">
                <button class="fractal-btn" onclick="generateMandelbrot()">🌀 Mandelbrot Set</button>
                <button class="fractal-btn" onclick="generateJuliaSet()">🎭 Julia Set</button>
                <button class="fractal-btn" onclick="generateFractalTree()">🌳 Fractal Tree</button>
                <button class="fractal-btn" onclick="generateSierpinski()">🔺 Sierpinski Triangle</button>
                <button class="fractal-btn" onclick="animateFractal()">✨ Animate</button>
                <button class="fractal-btn" onclick="clearFractalCanvas()">🧹 Clear</button>
            </div>
            
            <div class="fractal-canvas" id="fractalCanvas">
                <canvas id="fractalCanvasElement" width="800" height="500" style="width: 100%; height: 100%; border-radius: 15px;"></canvas>
                <div class="fractal-stats" id="fractalStats">
                    <div class="stat-card">
                        <div class="stat-value" id="iterationCount">0</div>
                        <div class="stat-label">Iterations</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="zoomLevel">1.0</div>
                        <div class="stat-label">Zoom Level</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="fractalType">None</div>
                        <div class="stat-label">Fractal Type</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="renderTime">0ms</div>
                        <div class="stat-label">Render Time</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let clickCount = 0;
        let typingIndex = 0;
        const typingTexts = [
            "Welcome to JavaScript!",
            "Interactive Web Magic!",
            "Dynamic Animations!",
            "Amazing Effects!",
            "Scroll to Explore!"
        ];
        let currentTextIndex = 0;
        
        // Initialize page
        document.addEventListener('DOMContentLoaded', function() {
            createFloatingElements();
            setupNavigation();
            setupParticleCanvas();
            setupInteractiveArea();
            setupColorDemo();
            startTextAnimation();
            setupMouseTracker();
            setupDynamicPhysics();
            setupDataVisualization();
            setupFractalDemo();
        });
        
        // Create floating background elements
        function createFloatingElements() {
            const container = document.getElementById('floatingElements');
            for (let i = 0; i < 15; i++) {
                const element = document.createElement('div');
                element.className = 'floating-element';
                element.style.left = Math.random() * 100 + '%';
                element.style.top = Math.random() * 100 + '%';
                element.style.animationDelay = Math.random() * 6 + 's';
                element.style.animationDuration = (Math.random() * 4 + 4) + 's';
                container.appendChild(element);
            }
        }
        
        // Navigation setup
        function setupNavigation() {
            const dots = document.querySelectorAll('.nav-dot');
            dots.forEach((dot, index) => {
                dot.addEventListener('click', () => {
                    scrollToZone(index + 1);
                });
            });
            
            // Update active dot on scroll
            window.addEventListener('scroll', updateActiveDot);
        }
        
        function scrollToZone(zoneNumber) {
            const zone = document.getElementById(`zone${zoneNumber}`);
            zone.scrollIntoView({ behavior: 'smooth' });
        }
        
        function updateActiveDot() {
            const zones = document.querySelectorAll('.zone');
            const dots = document.querySelectorAll('.nav-dot');
            
            zones.forEach((zone, index) => {
                const rect = zone.getBoundingClientRect();
                if (rect.top <= window.innerHeight / 2 && rect.bottom >= window.innerHeight / 2) {
                    dots.forEach(dot => dot.classList.remove('active'));
                    dots[index].classList.add('active');
                }
            });
        }
        
        // Fireworks functionality
        function launchFireworks() {
            for (let burst = 0; burst < 3; burst++) {
                setTimeout(() => {
                    launchSingleFirework();
                }, burst * 400);
            }
        }
        
        function launchSingleFirework() {
            const launchX = 100 + Math.random() * (window.innerWidth - 200);
            const launchY = window.innerHeight - 50;
            const explosionX = launchX + (Math.random() - 0.5) * 200;
            const explosionY = 100 + Math.random() * (window.innerHeight * 0.6);
            
            const rocket = document.createElement('div');
            rocket.style.position = 'fixed';
            rocket.style.left = launchX + 'px';
            rocket.style.top = launchY + 'px';
            rocket.style.width = '8px';
            rocket.style.height = '16px';
            rocket.style.background = 'linear-gradient(to top, #ff6b6b, #feca57)';
            rocket.style.borderRadius = '4px';
            rocket.style.boxShadow = '0 0 20px #ff6b6b, 0 0 40px #feca57';
            rocket.style.pointerEvents = 'none';
            rocket.style.zIndex = '1000';
            rocket.style.border = '1px solid #fff';
            
            document.body.appendChild(rocket);
            
            const flightTime = 800 + Math.random() * 400;
            
            rocket.animate([
                {
                    transform: 'translate(0, 0) scale(1)',
                    opacity: 1
                },
                {
                    transform: `translate(${explosionX - launchX}px, ${explosionY - launchY}px) scale(0.5)`,
                    opacity: 0.8
                }
            ], {
                duration: flightTime,
                easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
            }).onfinish = () => {
                rocket.remove();
                setTimeout(() => {
                    createFireworkBurst(explosionX, explosionY);
                }, 100);
            };
            
            createRocketTrail(launchX, launchY, explosionX, explosionY, flightTime);
        }
        
        function createRocketTrail(startX, startY, endX, endY, duration) {
            const trailCount = 15;
            const trailInterval = duration / trailCount;
            
            for (let i = 0; i < trailCount; i++) {
                setTimeout(() => {
                    const progress = i / trailCount;
                    const trailX = startX + (endX - startX) * progress;
                    const trailY = startY + (endY - startY) * progress;
                    
                    const trail = document.createElement('div');
                    trail.style.position = 'fixed';
                    trail.style.left = trailX + 'px';
                    trail.style.top = trailY + 'px';
                    trail.style.width = '4px';
                    trail.style.height = '4px';
                    trail.style.background = '#feca57';
                    trail.style.borderRadius = '50%';
                    trail.style.boxShadow = '0 0 10px #feca57, 0 0 20px #ff6b6b';
                    trail.style.pointerEvents = 'none';
                    trail.style.zIndex = '999';
                    
                    document.body.appendChild(trail);
                    
                    trail.animate([
                        { opacity: 1, transform: 'scale(1)' },
                        { opacity: 0, transform: 'scale(0)' }
                    ], {
                        duration: 500,
                        easing: 'ease-out'
                    }).onfinish = () => trail.remove();
                }, i * trailInterval);
            }
        }
        
        function createFireworkBurst(centerX, centerY) {
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3', '#54a0ff', '#5f27cd'];
            const particleCount = 40 + Math.random() * 20;
            
            for (let i = 0; i < particleCount; i++) {
                const firework = document.createElement('div');
                firework.className = 'firework';
                firework.style.left = centerX + 'px';
                firework.style.top = centerY + 'px';
                firework.style.background = colors[Math.floor(Math.random() * colors.length)];
                firework.style.boxShadow = `0 0 10px ${colors[Math.floor(Math.random() * colors.length)]}`;
                
                document.body.appendChild(firework);
                
                const angle = Math.random() * Math.PI * 2;
                const velocity = 80 + Math.random() * 120;
                const deltaX = Math.cos(angle) * velocity;
                const deltaY = Math.sin(angle) * velocity;
                
                firework.animate([
                    { transform: 'translate(0, 0) scale(1)', opacity: 1 },
                    { transform: `translate(${deltaX}px, ${deltaY}px) scale(0)`, opacity: 0 }
                ], {
                    duration: 1200 + Math.random() * 800,
                    easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
                }).onfinish = () => firework.remove();
            }
        }
        
        // Particle canvas setup
        function setupParticleCanvas() {
            const canvas = document.getElementById('particleCanvas');
            const ctx = canvas.getContext('2d');
            let particles = [];
            
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            function createParticle(x, y) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    life: 1,
                    decay: Math.random() * 0.02 + 0.01,
                    size: Math.random() * 4 + 2,
                    color: `hsl(${Math.random() * 360}, 70%, 60%)`
                });
            }
            
            function updateParticles() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= p.decay;
                    
                    if (p.life <= 0) {
                        particles.splice(i, 1);
                        continue;
                    }
                    
                    ctx.save();
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
                
                requestAnimationFrame(updateParticles);
            }
            
            updateParticles();
            
            // Store createParticle function globally for interactive area
            window.createParticle = createParticle;
        }
        
        
        
        // Text animation setup
        function startTextAnimation() {
            const textElement = document.getElementById('animatedText');
            
            function typeText() {
                const currentText = typingTexts[currentTextIndex];
                textElement.textContent = '';
                textElement.classList.add('typing-text');
                
                let i = 0;
                function typeChar() {
                    if (i < currentText.length) {
                        textElement.textContent += currentText.charAt(i);
                        i++;
                        setTimeout(typeChar, 100);
                    } else {
                        textElement.classList.remove('typing-text');
                        setTimeout(() => {
                            currentTextIndex = (currentTextIndex + 1) % typingTexts.length;
                            typeText();
                        }, 2000);
                    }
                }
                
                setTimeout(typeChar, 500);
            }
            
            typeText();
        }
        
        // Advanced Mouse Tracking System
        function setupMouseTracker() {
            const tracker = document.createElement('div');
            tracker.className = 'mouse-tracker';
            document.body.appendChild(tracker);
            
            let mouseX = 0, mouseY = 0;
            let targetX = 0, targetY = 0;
            
            document.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            
            function updateTracker() {
                // Smooth following with easing
                targetX += (mouseX - targetX) * 0.1;
                targetY += (mouseY - targetY) * 0.1;
                
                tracker.style.left = targetX - 10 + 'px';
                tracker.style.top = targetY - 10 + 'px';
                
                // Dynamic size based on speed
                const speed = Math.sqrt(Math.pow(mouseX - targetX, 2) + Math.pow(mouseY - targetY, 2));
                const size = 20 + speed * 0.5;
                tracker.style.width = size + 'px';
                tracker.style.height = size + 'px';
                
                requestAnimationFrame(updateTracker);
            }
            updateTracker();
        }
        
        // Dynamic Physics System
        function setupDynamicPhysics() {
            const physicsElements = [];
            let animationId;
            
            function createPhysicsElement(x, y) {
                const element = document.createElement('div');
                element.className = 'dynamic-element';
                element.style.left = x + 'px';
                element.style.top = y + 'px';
                element.style.opacity = '1';
                
                physicsElements.push({
                    element: element,
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    life: 1,
                    mass: Math.random() * 2 + 1
                });
                
                document.body.appendChild(element);
            }
            
            function updatePhysics() {
                physicsElements.forEach((obj, index) => {
                    // Apply gravity
                    obj.vy += 0.1;
                    
                    // Apply air resistance
                    obj.vx *= 0.99;
                    obj.vy *= 0.99;
                    
                    // Update position
                    obj.x += obj.vx;
                    obj.y += obj.vy;
                    
                    // Bounce off walls
                    if (obj.x < 0 || obj.x > window.innerWidth - 10) {
                        obj.vx *= -0.8;
                        obj.x = Math.max(0, Math.min(window.innerWidth - 10, obj.x));
                    }
                    if (obj.y > window.innerHeight - 10) {
                        obj.vy *= -0.8;
                        obj.y = window.innerHeight - 10;
                    }
                    
                    // Update element position
                    obj.element.style.left = obj.x + 'px';
                    obj.element.style.top = obj.y + 'px';
                    
                    // Fade out over time
                    obj.life -= 0.01;
                    obj.element.style.opacity = obj.life;
                    
                    // Remove dead elements
                    if (obj.life <= 0) {
                        obj.element.remove();
                        physicsElements.splice(index, 1);
                    }
                });
                
                animationId = requestAnimationFrame(updatePhysics);
            }
            
            updatePhysics();
            
            // Create elements on click
            document.addEventListener('click', (e) => {
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        createPhysicsElement(e.clientX + (Math.random() - 0.5) * 50, e.clientY + (Math.random() - 0.5) * 50);
                    }, i * 50);
                }
            });
        }
        
        // Real-time Data Visualization
        function setupDataVisualization() {
            const dataDisplay = document.createElement('div');
            dataDisplay.className = 'data-visualization';
            dataDisplay.style.top = '20px';
            dataDisplay.style.left = '20px';
            document.body.appendChild(dataDisplay);
            
            let frameCount = 0;
            let lastTime = Date.now();
            let fps = 0;
            
            function updateData() {
                frameCount++;
                const now = Date.now();
                
                if (now - lastTime >= 1000) {
                    fps = frameCount;
                    frameCount = 0;
                    lastTime = now;
                }
                
                const mousePos = getMousePosition();
                const scrollPercent = (window.scrollY / (document.body.scrollHeight - window.innerHeight)) * 100;
                
                dataDisplay.innerHTML = `
                    FPS: ${fps}<br>
                    Mouse: ${mousePos.x}, ${mousePos.y}<br>
                    Scroll: ${scrollPercent.toFixed(1)}%<br>
                    Time: ${new Date().toLocaleTimeString()}<br>
                    Particles: ${window.particleCount || 0}
                `;
                
                requestAnimationFrame(updateData);
            }
            
            function getMousePosition() {
                return { x: mouseX || 0, y: mouseY || 0 };
            }
            
            updateData();
        }
        
        // Enhanced Interactive Area with Gravity Wells
        function setupInteractiveArea() {
            const area = document.getElementById('interactiveArea');
            let mouseX = 0, mouseY = 0;
            let gravityWells = [];
            
            area.addEventListener('mousemove', (e) => {
                const rect = area.getBoundingClientRect();
                mouseX = e.clientX - rect.left;
                mouseY = e.clientY - rect.top;
                
                // Create gravity well
                const well = document.createElement('div');
                well.className = 'gravity-well';
                well.style.left = mouseX - 50 + 'px';
                well.style.top = mouseY - 50 + 'px';
                well.style.width = '100px';
                well.style.height = '100px';
                well.style.background = 'radial-gradient(circle, rgba(255,255,255,0.2), transparent)';
                well.style.border = '2px solid rgba(255,255,255,0.3)';
                
                area.appendChild(well);
                gravityWells.push(well);
                
                // Remove old wells
                if (gravityWells.length > 3) {
                    const oldWell = gravityWells.shift();
                    oldWell.remove();
                }
                
                // Create particles with gravity effect
                if (Math.random() < 0.4) {
                    createGravityParticle(e.clientX, e.clientY, mouseX, mouseY);
                }
            });
            
            area.addEventListener('click', (e) => {
                const rect = area.getBoundingClientRect();
                const x = e.clientX;
                const y = e.clientY;
                
                // Create gravity burst
                for (let i = 0; i < 30; i++) {
                    setTimeout(() => {
                        createGravityParticle(x, y, mouseX, mouseY);
                    }, i * 20);
                }
            });
            
            function createGravityParticle(screenX, screenY, areaX, areaY) {
                const particle = document.createElement('div');
                particle.style.position = 'fixed';
                particle.style.left = screenX + 'px';
                particle.style.top = screenY + 'px';
                particle.style.width = '4px';
                particle.style.height = '4px';
                particle.style.background = `hsl(${Math.random() * 360}, 70%, 60%)`;
                particle.style.borderRadius = '50%';
                particle.style.pointerEvents = 'none';
                particle.style.zIndex = '1000';
                particle.style.boxShadow = '0 0 10px currentColor';
                
                document.body.appendChild(particle);
                
                // Physics simulation
                let x = screenX;
                let y = screenY;
                let vx = (Math.random() - 0.5) * 8;
                let vy = (Math.random() - 0.5) * 8;
                let life = 1;
                
                function updateParticle() {
                    // Apply gravity towards mouse
                    const dx = mouseX - x;
                    const dy = mouseY - y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 0) {
                        const force = 0.5;
                        vx += (dx / distance) * force;
                        vy += (dy / distance) * force;
                    }
                    
                    // Update position
                    x += vx;
                    y += vy;
                    
                    // Apply friction
                    vx *= 0.98;
                    vy *= 0.98;
                    
                    particle.style.left = x + 'px';
                    particle.style.top = y + 'px';
                    
                    // Fade out
                    life -= 0.02;
                    particle.style.opacity = life;
                    
                    if (life > 0) {
                        requestAnimationFrame(updateParticle);
                    } else {
                        particle.remove();
                    }
                }
                
                updateParticle();
            }
        }
        
        // Enhanced Color Demo with Complex Calculations
        function setupColorDemo() {
            const demo = document.getElementById('colorDemo');
            let hue = 0;
            let saturation = 70;
            let lightness = 60;
            let isAnimating = false;
            
            demo.addEventListener('click', () => {
                if (isAnimating) return;
                isAnimating = true;
                
                // Complex color calculation
                hue = (hue + Math.random() * 60 + 30) % 360;
                saturation = 50 + Math.random() * 40;
                lightness = 40 + Math.random() * 40;
                
                // Animate color transition
                const startHue = parseInt(demo.style.background.match(/hsl\((\d+)/)?.[1] || 0);
                const startSaturation = parseInt(demo.style.background.match(/hsl\(\d+,\s*(\d+)%/) || [0, 70])[1];
                const startLightness = parseInt(demo.style.background.match(/hsl\(\d+,\s*\d+%,\s*(\d+)%/) || [0, 60])[1];
                
                let progress = 0;
                function animateColor() {
                    progress += 0.05;
                    
                    const currentHue = startHue + (hue - startHue) * progress;
                    const currentSaturation = startSaturation + (saturation - startSaturation) * progress;
                    const currentLightness = startLightness + (lightness - startLightness) * progress;
                    
                    demo.style.background = `linear-gradient(45deg, hsl(${currentHue}, ${currentSaturation}%, ${currentLightness}%), hsl(${(currentHue + 120) % 360}, ${currentSaturation}%, ${currentLightness}%))`;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateColor);
                    } else {
                        isAnimating = false;
                    }
                }
                
                animateColor();
                
                // Create complex ripple effect
                createComplexRipple(demo);
            });
            
            function createComplexRipple(element) {
                const rect = element.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        const ripple = document.createElement('div');
                        ripple.style.position = 'fixed';
                        ripple.style.left = centerX + 'px';
                        ripple.style.top = centerY + 'px';
                        ripple.style.width = '0';
                        ripple.style.height = '0';
                        ripple.style.borderRadius = '50%';
                        ripple.style.background = `hsla(${hue}, ${saturation}%, ${lightness}%, 0.3)`;
                        ripple.style.transform = 'translate(-50%, -50%)';
                        ripple.style.pointerEvents = 'none';
                        ripple.style.zIndex = '1000';
                        
                        document.body.appendChild(ripple);
                        
                        ripple.animate([
                            {
                                width: '0px',
                                height: '0px',
                                opacity: 0.8
                            },
                            {
                                width: '300px',
                                height: '300px',
                                opacity: 0
                            }
                        ], {
                            duration: 1000 + i * 200,
                            easing: 'ease-out'
                        }).onfinish = () => ripple.remove();
                    }, i * 100);
                }
            }
        }
        
        // Animated Fractal Demo System
        let fractalCanvas, fractalCtx;
        let fractalStats = {
            iterationCount: 0,
            zoomLevel: 1.0,
            fractalType: 'None',
            renderTime: 0
        };
        let animationId = null;
        let animationTime = 0;
        
        const randomWords = [
            "JavaScript", "Random", "Function", "Algorithm", "Probability", "Distribution",
            "Procedural", "Generation", "Chaos", "Order", "Pattern", "Sequence",
            "Entropy", "Variance", "Deviation", "Correlation", "Regression", "Analysis",
            "Simulation", "Modeling", "Prediction", "Optimization", "Heuristic", "Stochastic"
        ];
        
        function setupRandomDemo() {
            updateRandomStats();
        }
        
        function updateRandomStats() {
            document.getElementById('pointCount').textContent = randomStats.pointCount;
            document.getElementById('randomSeed').textContent = randomStats.randomSeed;
            document.getElementById('avgDistance').textContent = randomStats.avgDistance.toFixed(1);
            document.getElementById('randomWords').textContent = randomStats.randomWords;
        }
        
        function generateRandomPoints() {
            const canvas = document.getElementById('randomCanvas');
            const rect = canvas.getBoundingClientRect();
            
            for (let i = 0; i < 50; i++) {
                const point = document.createElement('div');
                point.className = 'random-point';
                
                // Generate random position within canvas
                const x = Math.random() * (rect.width - 20);
                const y = Math.random() * (rect.height - 20);
                
                point.style.left = x + 'px';
                point.style.top = y + 'px';
                
                // Random color using HSL
                const hue = Math.random() * 360;
                const saturation = 70 + Math.random() * 30;
                const lightness = 50 + Math.random() * 30;
                point.style.background = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                point.style.boxShadow = `0 0 10px hsl(${hue}, ${saturation}%, ${lightness}%)`;
                
                // Random size
                const size = 3 + Math.random() * 6;
                point.style.width = size + 'px';
                point.style.height = size + 'px';
                
                canvas.appendChild(point);
                
                // Store point data
                randomStats.points.push({ x: x + 10, y: y + 10 });
                randomStats.pointCount++;
                
                // Calculate average distance
                if (randomStats.points.length > 1) {
                    let totalDistance = 0;
                    for (let j = 0; j < randomStats.points.length - 1; j++) {
                        const dx = randomStats.points[j].x - randomStats.points[randomStats.points.length - 1].x;
                        const dy = randomStats.points[j].y - randomStats.points[randomStats.points.length - 1].y;
                        totalDistance += Math.sqrt(dx * dx + dy * dy);
                    }
                    randomStats.avgDistance = totalDistance / (randomStats.points.length - 1);
                }
                
                // Animate point appearance
                point.style.opacity = '0';
                point.style.transform = 'scale(0)';
                point.animate([
                    { opacity: 0, transform: 'scale(0)' },
                    { opacity: 1, transform: 'scale(1)' }
                ], {
                    duration: 300 + Math.random() * 200,
                    easing: 'ease-out'
                });
            }
            
            updateRandomStats();
        }
        
        function generateRandomWalk() {
            const canvas = document.getElementById('randomCanvas');
            const rect = canvas.getBoundingClientRect();
            
            // Start from center
            let x = rect.width / 2;
            let y = rect.height / 2;
            
            const walkPoints = [];
            
            for (let i = 0; i < 100; i++) {
                const point = document.createElement('div');
                point.className = 'random-point';
                
                // Random walk step
                const angle = Math.random() * Math.PI * 2;
                const stepSize = 5 + Math.random() * 10;
                x += Math.cos(angle) * stepSize;
                y += Math.sin(angle) * stepSize;
                
                // Keep within bounds
                x = Math.max(10, Math.min(rect.width - 10, x));
                y = Math.max(10, Math.min(rect.height - 10, y));
                
                point.style.left = x + 'px';
                point.style.top = y + 'px';
                
                // Color based on step number
                const hue = (i / 100) * 360;
                point.style.background = `hsl(${hue}, 70%, 60%)`;
                point.style.boxShadow = `0 0 8px hsl(${hue}, 70%, 60%)`;
                
                // Size decreases over time
                const size = 6 - (i / 100) * 4;
                point.style.width = size + 'px';
                point.style.height = size + 'px';
                
                canvas.appendChild(point);
                walkPoints.push({ x, y });
                
                // Connect points with lines
                if (i > 0) {
                    const line = document.createElement('div');
                    line.className = 'random-line';
                    
                    const prevPoint = walkPoints[i - 1];
                    const dx = x - prevPoint.x;
                    const dy = y - prevPoint.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx);
                    
                    line.style.left = prevPoint.x + 'px';
                    line.style.top = prevPoint.y + 'px';
                    line.style.width = distance + 'px';
                    line.style.transform = `rotate(${angle}rad)`;
                    line.style.transformOrigin = '0 0';
                    
                    canvas.appendChild(line);
                }
                
                randomStats.pointCount++;
            }
            
            updateRandomStats();
        }
        
        function generateRandomCircles() {
            const canvas = document.getElementById('randomCanvas');
            const rect = canvas.getBoundingClientRect();
            
            for (let i = 0; i < 20; i++) {
                const circle = document.createElement('div');
                circle.style.position = 'absolute';
                circle.style.borderRadius = '50%';
                circle.style.pointerEvents = 'none';
                
                // Random position and size
                const x = Math.random() * (rect.width - 100);
                const y = Math.random() * (rect.height - 100);
                const size = 20 + Math.random() * 80;
                
                circle.style.left = x + 'px';
                circle.style.top = y + 'px';
                circle.style.width = size + 'px';
                circle.style.height = size + 'px';
                
                // Random color and transparency
                const hue = Math.random() * 360;
                const alpha = 0.1 + Math.random() * 0.3;
                circle.style.background = `hsla(${hue}, 70%, 60%, ${alpha})`;
                circle.style.border = `2px solid hsla(${hue}, 70%, 60%, 0.8)`;
                
                canvas.appendChild(circle);
                
                // Animate circle appearance
                circle.style.opacity = '0';
                circle.style.transform = 'scale(0)';
                circle.animate([
                    { opacity: 0, transform: 'scale(0)' },
                    { opacity: 1, transform: 'scale(1)' }
                ], {
                    duration: 500 + Math.random() * 500,
                    easing: 'ease-out'
                });
                
                randomStats.pointCount++;
            }
            
            updateRandomStats();
        }
        
        function generateRandomLines() {
            const canvas = document.getElementById('randomCanvas');
            const rect = canvas.getBoundingClientRect();
            
            for (let i = 0; i < 30; i++) {
                const line = document.createElement('div');
                line.className = 'random-line';
                
                // Random start and end points
                const x1 = Math.random() * rect.width;
                const y1 = Math.random() * rect.height;
                const x2 = Math.random() * rect.width;
                const y2 = Math.random() * rect.height;
                
                // Calculate line properties
                const dx = x2 - x1;
                const dy = y2 - y1;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx);
                
                line.style.left = x1 + 'px';
                line.style.top = y1 + 'px';
                line.style.width = distance + 'px';
                line.style.transform = `rotate(${angle}rad)`;
                line.style.transformOrigin = '0 0';
                
                // Random color
                const hue = Math.random() * 360;
                line.style.background = `linear-gradient(90deg, transparent, hsl(${hue}, 70%, 60%), transparent)`;
                
                canvas.appendChild(line);
                
                randomStats.pointCount++;
            }
            
            updateRandomStats();
        }
        
        function generateRandomText() {
            const canvas = document.getElementById('randomCanvas');
            const rect = canvas.getBoundingClientRect();
            
            for (let i = 0; i < 15; i++) {
                const textElement = document.createElement('div');
                textElement.style.position = 'absolute';
                textElement.style.pointerEvents = 'none';
                textElement.style.fontSize = (12 + Math.random() * 16) + 'px';
                textElement.style.fontWeight = 'bold';
                textElement.style.fontFamily = 'monospace';
                
                // Random position
                const x = Math.random() * (rect.width - 100);
                const y = Math.random() * (rect.height - 30);
                
                textElement.style.left = x + 'px';
                textElement.style.top = y + 'px';
                
                // Random word
                const word = randomWords[Math.floor(Math.random() * randomWords.length)];
                textElement.textContent = word;
                
                // Random color
                const hue = Math.random() * 360;
                textElement.style.color = `hsl(${hue}, 70%, 60%)`;
                textElement.style.textShadow = `0 0 10px hsl(${hue}, 70%, 60%)`;
                
                canvas.appendChild(textElement);
                
                // Animate text appearance
                textElement.style.opacity = '0';
                textElement.style.transform = 'scale(0) rotate(180deg)';
                textElement.animate([
                    { opacity: 0, transform: 'scale(0) rotate(180deg)' },
                    { opacity: 1, transform: 'scale(1) rotate(0deg)' }
                ], {
                    duration: 400 + Math.random() * 400,
                    easing: 'ease-out'
                });
                
                randomStats.randomWords++;
            }
            
            updateRandomStats();
        }
        
        function clearRandomCanvas() {
            const canvas = document.getElementById('randomCanvas');
            const elements = canvas.querySelectorAll('.random-point, .random-line, div[style*="position: absolute"]');
            elements.forEach(element => {
                if (element.id !== 'randomStats') {
                    element.remove();
                }
            });
            
            // Reset stats
            randomStats.pointCount = 0;
            randomStats.points = [];
            randomStats.avgDistance = 0;
            randomStats.randomWords = 0;
            randomStats.randomSeed = Math.floor(Math.random() * 10000);
            
            updateRandomStats();
        }
        
        function setupFractalDemo() {
            fractalCanvas = document.getElementById('fractalCanvasElement');
            fractalCtx = fractalCanvas.getContext('2d');
            
            // Set canvas size
            const rect = fractalCanvas.getBoundingClientRect();
            fractalCanvas.width = rect.width;
            fractalCanvas.height = rect.height;
            
            updateFractalStats();
        }
        
        function updateFractalStats() {
            document.getElementById('iterationCount').textContent = fractalStats.iterationCount;
            document.getElementById('zoomLevel').textContent = fractalStats.zoomLevel.toFixed(2);
            document.getElementById('fractalType').textContent = fractalStats.fractalType;
            document.getElementById('renderTime').textContent = fractalStats.renderTime + 'ms';
        }
        
        function generateMandelbrot() {
            const startTime = performance.now();
            fractalStats.fractalType = 'Mandelbrot Set';
            fractalStats.iterationCount = 0;
            
            const width = fractalCanvas.width;
            const height = fractalCanvas.height;
            const maxIterations = 50;
            const zoom = fractalStats.zoomLevel;
            
            fractalCtx.fillStyle = '#000';
            fractalCtx.fillRect(0, 0, width, height);
            
            const imageData = fractalCtx.createImageData(width, height);
            const data = imageData.data;
            
            for (let x = 0; x < width; x += 2) {
                for (let y = 0; y < height; y += 2) {
                    const real = (x - width / 2) / (0.5 * zoom * width) - 0.5;
                    const imag = (y - height / 2) / (0.5 * zoom * height);
                    
                    let zReal = 0, zImag = 0;
                    let iterations = 0;
                    
                    while (iterations < maxIterations && zReal * zReal + zImag * zImag < 4) {
                        const temp = zReal * zReal - zImag * zImag + real;
                        zImag = 2 * zReal * zImag + imag;
                        zReal = temp;
                        iterations++;
                        fractalStats.iterationCount++;
                    }
                    
                    const color = getFractalColor(iterations, maxIterations);
                    const index = (y * width + x) * 4;
                    data[index] = color.r;
                    data[index + 1] = color.g;
                    data[index + 2] = color.b;
                    data[index + 3] = 255;
                }
            }
            
            fractalCtx.putImageData(imageData, 0, 0);
            fractalStats.renderTime = Math.round(performance.now() - startTime);
            updateFractalStats();
        }
        
        function generateJuliaSet() {
            const startTime = performance.now();
            fractalStats.fractalType = 'Julia Set';
            fractalStats.iterationCount = 0;
            
            const width = fractalCanvas.width;
            const height = fractalCanvas.height;
            const maxIterations = 50;
            
            const cReal = 0.285 + 0.01 * Math.sin(animationTime * 0.01);
            const cImag = 0.01 + 0.01 * Math.cos(animationTime * 0.01);
            
            fractalCtx.fillStyle = '#000';
            fractalCtx.fillRect(0, 0, width, height);
            
            const imageData = fractalCtx.createImageData(width, height);
            const data = imageData.data;
            
            for (let x = 0; x < width; x += 2) {
                for (let y = 0; y < height; y += 2) {
                    const real = (x - width / 2) / (0.5 * width);
                    const imag = (y - height / 2) / (0.5 * height);
                    
                    let zReal = real, zImag = imag;
                    let iterations = 0;
                    
                    while (iterations < maxIterations && zReal * zReal + zImag * zImag < 4) {
                        const temp = zReal * zReal - zImag * zImag + cReal;
                        zImag = 2 * zReal * zImag + cImag;
                        zReal = temp;
                        iterations++;
                        fractalStats.iterationCount++;
                    }
                    
                    const color = getFractalColor(iterations, maxIterations);
                    const index = (y * width + x) * 4;
                    data[index] = color.r;
                    data[index + 1] = color.g;
                    data[index + 2] = color.b;
                    data[index + 3] = 255;
                }
            }
            
            fractalCtx.putImageData(imageData, 0, 0);
            fractalStats.renderTime = Math.round(performance.now() - startTime);
            updateFractalStats();
        }
        
        function generateFractalTree() {
            const startTime = performance.now();
            fractalStats.fractalType = 'Fractal Tree';
            fractalStats.iterationCount = 0;
            
            const width = fractalCanvas.width;
            const height = fractalCanvas.height;
            
            fractalCtx.fillStyle = '#000';
            fractalCtx.fillRect(0, 0, width, height);
            
            fractalCtx.strokeStyle = '#8B4513';
            fractalCtx.lineWidth = 3;
            fractalCtx.lineCap = 'round';
            
            const startX = width / 2;
            const startY = height - 50;
            const initialLength = 100;
            const initialAngle = -Math.PI / 2;
            
            drawBranch(startX, startY, initialLength, initialAngle, 0, 7);
            
            fractalStats.renderTime = Math.round(performance.now() - startTime);
            updateFractalStats();
        }
        
        function drawBranch(x, y, length, angle, depth, maxDepth) {
            if (depth >= maxDepth) return;
            
            fractalStats.iterationCount++;
            
            const endX = x + Math.cos(angle) * length;
            const endY = y + Math.sin(angle) * length;
            
            const hue = 120 - depth * 15;
            fractalCtx.strokeStyle = `hsl(${hue}, 70%, 50%)`;
            fractalCtx.lineWidth = Math.max(1, 5 - depth * 0.5);
            
            fractalCtx.beginPath();
            fractalCtx.moveTo(x, y);
            fractalCtx.lineTo(endX, endY);
            fractalCtx.stroke();
            
            const newLength = length * 0.7;
            const angleChange = Math.PI / 6;
            
            drawBranch(endX, endY, newLength, angle - angleChange, depth + 1, maxDepth);
            drawBranch(endX, endY, newLength, angle + angleChange, depth + 1, maxDepth);
        }
        
        function generateSierpinski() {
            const startTime = performance.now();
            fractalStats.fractalType = 'Sierpinski Triangle';
            fractalStats.iterationCount = 0;
            
            const width = fractalCanvas.width;
            const height = fractalCanvas.height;
            
            fractalCtx.fillStyle = '#000';
            fractalCtx.fillRect(0, 0, width, height);
            
            const size = Math.min(width, height) * 0.8;
            const centerX = width / 2;
            const centerY = height / 2;
            
            drawSierpinskiTriangle(centerX, centerY - size/2, size, 0, 5);
            
            fractalStats.renderTime = Math.round(performance.now() - startTime);
            updateFractalStats();
        }
        
        function drawSierpinskiTriangle(x, y, size, depth, maxDepth) {
            if (depth >= maxDepth) return;
            
            fractalStats.iterationCount++;
            
            const height = size * Math.sqrt(3) / 2;
            
            const hue = 200 + depth * 20;
            fractalCtx.fillStyle = `hsla(${hue}, 70%, 60%, 0.8)`;
            fractalCtx.strokeStyle = `hsl(${hue}, 70%, 40%)`;
            fractalCtx.lineWidth = 1;
            
            fractalCtx.beginPath();
            fractalCtx.moveTo(x, y);
            fractalCtx.lineTo(x - size/2, y + height);
            fractalCtx.lineTo(x + size/2, y + height);
            fractalCtx.closePath();
            fractalCtx.fill();
            fractalCtx.stroke();
            
            const newSize = size / 2;
            const newHeight = height / 2;
            
            drawSierpinskiTriangle(x, y, newSize, depth + 1, maxDepth);
            drawSierpinskiTriangle(x - newSize/2, y + newHeight, newSize, depth + 1, maxDepth);
            drawSierpinskiTriangle(x + newSize/2, y + newHeight, newSize, depth + 1, maxDepth);
        }
        
        function getFractalColor(iterations, maxIterations) {
            if (iterations === maxIterations) {
                return { r: 0, g: 0, b: 0 };
            }
            
            const t = iterations / maxIterations;
            const hue = 240 + t * 120;
            const saturation = 80 + t * 20;
            const lightness = 30 + t * 40;
            
            return hslToRgb(hue, saturation, lightness);
        }
        
        function hslToRgb(h, s, l) {
            h /= 360; s /= 100; l /= 100;
            const c = (1 - Math.abs(2 * l - 1)) * s;
            const x = c * (1 - Math.abs((h * 6) % 2 - 1));
            const m = l - c / 2;
            
            let r, g, b;
            if (h < 1/6) { r = c; g = x; b = 0; }
            else if (h < 2/6) { r = x; g = c; b = 0; }
            else if (h < 3/6) { r = 0; g = c; b = x; }
            else if (h < 4/6) { r = 0; g = x; b = c; }
            else if (h < 5/6) { r = x; g = 0; b = c; }
            else { r = c; g = 0; b = x; }
            
            return {
                r: Math.round((r + m) * 255),
                g: Math.round((g + m) * 255),
                b: Math.round((b + m) * 255)
            };
        }
        
        function animateFractal() {
            if (animationId) cancelAnimationFrame(animationId);
            
            animationTime = 0;
            
            function animate() {
                animationTime++;
                const cycle = Math.floor(animationTime / 60) % 4;
                
                switch (cycle) {
                    case 0:
                        fractalStats.zoomLevel = 1.0 + Math.sin(animationTime * 0.02) * 0.5;
                        generateMandelbrot();
                        break;
                    case 1: generateJuliaSet(); break;
                    case 2: generateFractalTree(); break;
                    case 3: generateSierpinski(); break;
                }
                
                animationId = requestAnimationFrame(animate);
            }
            
            animate();
        }
        
        function clearFractalCanvas() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            
            fractalCtx.fillStyle = '#000';
            fractalCtx.fillRect(0, 0, fractalCanvas.width, fractalCanvas.height);
            
            fractalStats.iterationCount = 0;
            fractalStats.zoomLevel = 1.0;
            fractalStats.fractalType = 'None';
            fractalStats.renderTime = 0;
            
            updateFractalStats();
        }
        
        // Add CSS for ripple animation
        const style = document.createElement('style');
        style.textContent = `
            @keyframes ripple {
                0% {
                    width: 0;
                    height: 0;
                    opacity: 1;
                }
                100% {
                    width: 200px;
                    height: 200px;
                    opacity: 0;
                }
            }
        `;
        document.head.appendChild(style);
    </script>
</body>
</html>